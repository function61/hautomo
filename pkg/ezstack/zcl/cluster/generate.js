#!/usr/local/bin/nodejs

const herdsman = require('zigbee-herdsman');

// TODO: manufacturer codes are in herdsman.Zcl.ManufacturerCode

// TODO: this is not pretty
var dataTypeTransform = {
	0x00: "ZclDataTypeNoData",
	0x08: "ZclDataTypeData8",
	0x09: "ZclDataTypeData16",
	0x0a: "ZclDataTypeData24",
	0x0b: "ZclDataTypeData32",
	0x0c: "ZclDataTypeData40",
	0x0d: "ZclDataTypeData48",
	0x0e: "ZclDataTypeData56",
	0x0f: "ZclDataTypeData64",
	0x10: "ZclDataTypeBoolean",
	0x18: "ZclDataTypeBitmap8",
	0x19: "ZclDataTypeBitmap16",
	0x1a: "ZclDataTypeBitmap24",
	0x1b: "ZclDataTypeBitmap32",
	0x1c: "ZclDataTypeBitmap40",
	0x1d: "ZclDataTypeBitmap48",
	0x1e: "ZclDataTypeBitmap56",
	0x1f: "ZclDataTypeBitmap64",
	0x20: "ZclDataTypeUint8",
	0x21: "ZclDataTypeUint16",
	0x22: "ZclDataTypeUint24",
	0x23: "ZclDataTypeUint32",
	0x24: "ZclDataTypeUint40",
	0x25: "ZclDataTypeUint48",
	0x26: "ZclDataTypeUint56",
	0x27: "ZclDataTypeUint64",
	0x28: "ZclDataTypeInt8",
	0x29: "ZclDataTypeInt16",
	0x2a: "ZclDataTypeInt24",
	0x2b: "ZclDataTypeInt32",
	0x2c: "ZclDataTypeInt40",
	0x2d: "ZclDataTypeInt48",
	0x2e: "ZclDataTypeInt56",
	0x2f: "ZclDataTypeInt64",
	0x30: "ZclDataTypeEnum8",
	0x31: "ZclDataTypeEnum16",
	0x38: "ZclDataTypeSemiPrec",
	0x39: "ZclDataTypeSinglePrec",
	0x3a: "ZclDataTypeDoublePrec",
	0x41: "ZclDataTypeOctetStr",
	0x42: "ZclDataTypeCharStr",
	0x43: "ZclDataTypeLongOctetStr",
	0x44: "ZclDataTypeLongCharStr",
	0x48: "ZclDataTypeArray",
	0x4c: "ZclDataTypeStruct",
	0x50: "ZclDataTypeSet",
	0x51: "ZclDataTypeBag",
	0xe0: "ZclDataTypeTod",
	0xe1: "ZclDataTypeDate",
	0xe2: "ZclDataTypeUtc",
	0xe8: "ZclDataTypeClusterId",
	0xe9: "ZclDataTypeAttrId",
	0xea: "ZclDataTypeBacOid",
	0xf0: "ZclDataTypeIeeeAddr",
	0xf1: "ZclDataType_128BitSecKey",
	0xff: "ZclDataTypeUnknown",
}

const toTitleCase = (input) => input[0].toUpperCase() + input.substr(1);
const goKey = (input) => toTitleCase(input);

class GoFile {
	clusterIds = [];
	clusterDefinitions = [];
	seenClusterIds = [];

	process(key, definition) {
		// of course there are duplicate cluster IDs
		// TODO: find out if we should/can support this. does zigbee-herdsman for example differentiate
		//       them based of device model ID?
		if (this.seenClusterIds.indexOf(definition.ID) !== -1) {
			return;
		}

		this.seenClusterIds.push(definition.ID);

		/* Definition looks like this (most attributes snipped for brevity):

			{
			    ID: 0,
			    attributes: {
			        zclVersion: {ID: 0, type: DataType.uint8},
			        alarmMask: {ID: 19, type: DataType.bitmap8},
			        disableLocalConfig: {ID: 20, type: DataType.bitmap8},
			    },
			    commands: {
			        resetFactDefault: {
			            ID: 0,
			            parameters: [
			            ],
			        },
			    },
			    commandsResponse: {},
			}
    	*/
		this.clusterIds.push(`Id${goKey(key)} ClusterId = ${definition.ID}`);

		const seenAttrIds = [];

		const attributeDescriptors = [];
		for (const name in definition.attributes) {
			const attr = definition.attributes[name];

			// of course there are multiple duplicate keys for the same attribute ID..
			// TODO: find out if we should/can support this. does zigbee-herdsman for example differentiate
			//       them based of different datatype?
			if (seenAttrIds.indexOf(attr.ID) !== -1) {
				continue;
			}

			seenAttrIds.push(attr.ID);

			// ZCL #8 is ZclDataTypeData8 in Go
			const zclTypeGoName = dataTypeTransform[attr.type];
			if (!zclTypeGoName) {
				throw new Error(`ZCL datatype not found: ${attr.type}`)
			}

			attributeDescriptors.push(`${attr.ID}: {"${name}",${zclTypeGoName},0}`);
		}

		const clusterDefinition = `Id${goKey(key)}: &Definition{
		name: "${key}",
		attributes: map[AttributeId]*AttributeDescriptor{
			${attributeDescriptors.concat('').join(",\n\t\t\t")}
		},
	},`;

		this.clusterDefinitions.push(clusterDefinition);
	}

	render() {
		return `package cluster

// Code generated by ${process.argv[1]} DO NOT EDIT.

const (
	${this.clusterIds.join("\n\t")}
)

var definitionLibrary = map[ClusterId]*Definition{
	${this.clusterDefinitions.join("\n\t")}
}

`;
	}
}

const file = new GoFile();

let count = 0; // TODO: remove
for (const key of Object.keys(herdsman.Zcl.Cluster)) {
	const definition = herdsman.Zcl.Cluster[key];

	file.process(key, definition);

	count++;

	if (count == -1) {
		break;
	}
}

console.log(file.render());
